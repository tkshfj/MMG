# sweep_mtlunet.yaml
program: main.py
method: bayes

metric:
  name: val/multi
  goal: maximize

parameters:
  # Fixed experiment knobs
  architecture: { value: multitask_unet }
  task:         { value: multitask }

  # Execution
  epochs:        { value: 40 }
  num_workers:   { value: 8 }
  optimizer:     { value: adamw }

  # Two-pass validation / calibration
  two_pass_val:        { value: true }
  calibration_method:  { values: [bal_acc, rate_match, youden, f1] }
  cal_min_tp:          { values: [5, 10, 20] }
  cal_warmup_epochs:   { values: [1, 2, 3] }
  cal_ema_beta:        { values: [0.10, 0.20, 0.30] }
  cal_max_delta:       { values: [0.05, 0.10, 0.20] }
  cal_auc_floor:       { values: [0.50, 0.55] }

  # Threshold guardrails (authoritative acceptance of thresholds)
  thr_warmup_epochs: { value: 5 }
  thr_min:           { value: 0.05 }
  thr_max:           { value: 0.95 }
  thr_posrate_min:   { value: 0.05 }
  thr_posrate_max:   { value: 0.95 }
  thr_min_tp:        { values: [0, 5, 10] }
  thr_min_tn:        { values: [0, 5] }
  thr_hysteresis:    { values: [0.01, 0.02, 0.03] }

  # Data / model topology
  in_channels:    { value: 1 }
  input_shape:    { value: [256, 256] }
  num_classes:    { value: 2 }
  class_balance:  { value: inverse }
  batch_size:     { values: [32, 64] }

  # Classification decision rule (threshold vs argmax)
  cls_decision: { value: threshold }

  # Segmentation
  seg_threshold: { values: [0.45, 0.50, 0.55] }

  # Multi-task objective
  multi_weight: { values: [0.55, 0.65, 0.75] }
  alpha:        { values: [1.0, 2.0] }
  beta:         { values: [0.5, 1.0] }

  # Core tunables
  lr:
    distribution: log_uniform_values
    min: 0.00003
    max: 0.0008
  weight_decay:
    distribution: log_uniform_values
    min: 0.00001
    max: 0.00005
  dropout_rate:
    distribution: uniform
    min: 0.18
    max: 0.24

  # LR schedules
  lr_scheduler: { value: warmcos }  # stabilized warmup + cosine
  # lr_strategy: { values: [cosine, warmcos, plateau] }  # choose among these; knobs apply per strategy

  # Optimizer param-group strategy (split head/backbone with decay/no-decay)
  param_groups:  { value: split }
  head_lr_scale: { value: 0.5 }
  head_wd_scale: { value: 1.5 }

  # cosine
  T_max:          { value: 40 }
  eta_min:        { value: 0.0 }

  # warmcos
  warmup_epochs:       { values: [0, 2, 3] }
  warmup_start_factor: { values: [0.1, 0.2] }

  # plateau
  plateau_metric:    { value: "val/auc" }
  plateau_mode:      { value: max }
  patience:          { value: 10 }
  factor:            { values: [0.5, 0.3] }
  plateau_threshold: { values: [0.0001, 0.0005] }

# parameters:
#   # Fixed experiment knobs
#   architecture: { value: multitask_unet }
#   task:         { value: multitask }
#   run_cap:      { value: 20 }

#   # Execution
#   epochs:            { value: 40 }
#   num_workers:       { value: 8 }
#   debug:             { value: true }
#   debug_transforms:  { value: false }
#   console_iter_log:  { value: false }
#   console_epoch_log: { value: true }
#   seed:              { value: 42 }
#   init_head_bias_from_prior: { value: true }
#   init_threshold_from_prior: { value: false }

#   # Two-pass validation / calibration (candidate source)
#   two_pass_val:   { value: true }
#   log_calibrated: { value: true }

#   calibration_method:   { values: [rate_match, youden, f1] }
#   cal_fallback:         { values: [rate_match, keep_last] }
#   cal_q_bounds:         { value: [0.10, 0.90] }
#   cal_min_tp:           { values: [5, 10, 20] }
#   cal_bootstraps:       { values: [0, 25] }
#   cal_warmup_epochs:    { values: [1, 2, 3] }
#   cal_init_threshold:   { values: [0.40, 0.50, 0.60] }
#   cal_ema_beta:         { values: [0.10, 0.20, 0.30] }
#   cal_max_delta:        { values: [0.05, 0.10, 0.20] }
#   # cal_rate_tolerance:   { values: [0.08, 0.10, 0.12, 0.15] }
#   cal_auc_floor:        { values: [0.50, 0.52, 0.55] }

#   # Guardrails (authoritative acceptance of thresholds)
#   thr_warmup_epochs: { value: 5 }  # { values: [1, 2, 3] }  # distinct from cal_warmup if desired
#   thr_min:           { value: 0.05 }
#   thr_max:           { value: 0.95 }
#   thr_posrate_min:   { value: 0.05 }  # reject all-neg (≈0)
#   thr_posrate_max:   { value: 0.95 }  # reject all-pos (≈1)
#   thr_min_tp:        { values: [0, 5, 10] }  # optional count sanity
#   thr_min_tn:        { values: [0, 5] }
#   thr_hysteresis:    { values: [0.01, 0.02, 0.03] }

#   # Decision-health (optional; bounds pos_rate around base rate)
#   enable_decision_health: { value: true }  # { values: [false, true] }
#   health_warmup:          { value: 1 }  # { values: [0, 1, 2] }
#   rate_tol_override:      { value: 0.10 }  # { values: [0.05, 0.10, 0.15] }
#   health_warmup_max_delta: { value: 0.2 }      # or 0.15–0.3 depending on spread
#   health_rate_gain: { value: 0.75}            # 0.5–1.0
#   health_iters_warmup: { value: 2 }            # 1–3

#   # Data / model topology
#   in_channels:  { value: 1 }
#   input_shape:  { value: [256, 256] }
#   num_classes:  { value: 2 }
#   class_balance: { value: inverse }
#   batch_size:   { values: [32, 64] }

#   # Binary classifier head behavior
#   binary_single_logit:        { value: true }
#   binary_bce_from_two_logits: { value: false }

#   # Loss / decision defaults (seed; acceptance/guardrails may override)
#   cls_loss:       { value: auto }
#   cls_decision:   { value: threshold }
#   cls_threshold:  { value: 0.5 }
#   positive_index: { value: 1 }

#   # Segmentation
#   seg_threshold: { values: [0.45, 0.50, 0.55] }

#   # Multi-task objective
#   multi_weight: { values: [0.55, 0.65, 0.75] }
#   alpha:        { values: [1.0, 2.0] }
#   beta:         { values: [0.5, 1.0] }

#   # Core tunables
#   lr:
#     distribution: log_uniform_values
#     min: 0.00003
#     max: 0.0008
#   weight_decay:
#     distribution: log_uniform_values
#     min: 0.00001
#     max: 0.00005
#   dropout_rate:
#     distribution: uniform
#     min: 0.18
#     max: 0.24

#   # LR strategy
#   lr_strategy: { values: [none, cosine, warmcos, plateau] }

#   # Cosine params
#   T_max:   { value: 40 }
#   eta_min: { value: 0.0 }

#   # Warmup params (used by warmcos)
#   warmup_epochs:      { values: [0, 2, 3] }
#   warmup_start_factor: { values: [0.1, 0.2] }

#   # Plateau params (only when lr_strategy=plateau)
#   plateau_metric:   { value: val/multi }
#   plateau_mode:     { value: max }
#   patience:         { value: 0 }
#   factor:           { values: [0.5, 0.3] }
#   plateau_threshold: { values: [0.0001, 0.0005] }

#   # Param-group strategy (split optimizer settings)
#   param_groups:  { values: [single, split] }
#   head_lr_scale: { value: 0.5 }  # lower LR on head
#   head_wd_scale: { value: 1.5 }  # slightly higher WD on head
#   head_keys:     { values: ["classification_head","classifier","mlp_head","fc","cls"] }
