# sweep_vit.yaml
program: main.py
method: bayes

metric:
  name: val/auc
  goal: maximize

parameters:
  # Core setup
  architecture:   { value: vit }
  task:           { value: classification }

  # Runtime
  epochs:         { value: 40 }
  num_workers:    { value: 8 }
  batch_size:     { values: [32, 64] }

  # Data
  in_channels:    { value: 1 }
  input_shape:    { value: [256, 256] }
  num_classes:    { value: 2 }

  # ViT backbone
  patch_size:     { value: 16 }
  hidden_size:    { values: [384, 768] }
  mlp_dim:        { values: [1536, 2048, 3072] }
  num_layers:     { values: [8, 10, 12] }
  num_heads:      { values: [6, 8, 12] }
  dropout_rate:
    distribution: uniform
    min: 0.18
    max: 0.24

  # Classification head / decisions
  head_logits:    { value: 1 }     # single-logit binary head → BCEWithLogits
  cls_loss:       { value: bce }
  init_head_bias_from_prior: { value: true }
  cls_decision:   { value: threshold }
  cls_threshold:  { values: [0.40, 0.50, 0.60] }  # seed; calibrated/guarded later

  # Validation & calibration
  two_pass_val:       { value: true }
  calibration_method: { values: [bal_acc, f1] }
  cal_max_delta:      { values: [0.05, 0.10, 0.20] }
  cal_auc_floor:      { values: [0.50, 0.55] }
  cal_ema_beta:       { values: [0.10, 0.20, 0.30] }
  rate_tol_override:  { value: 0.10 }

  # Threshold guardrails
  thr_warmup_epochs:  { value: 5 }
  thr_min:            { value: 0.05 }
  thr_max:            { value: 0.95 }
  thr_posrate_min:    { value: 0.05 }
  thr_posrate_max:    { value: 0.95 }
  thr_min_tp:         { values: [0, 5, 10] }
  thr_min_tn:         { values: [0, 5] }
  thr_hysteresis:     { values: [0.01, 0.02, 0.03] }

  # Optimizer & param groups
  optimizer:      { value: adamw }
  lr:
    distribution: log_uniform_values
    min: 0.00003
    max: 0.0008
  weight_decay:
    distribution: log_uniform_values
    min: 0.00001
    max: 0.00005
  param_groups:   { values: [split, auto] }  # { values: [single, split, auto] }
  head_lr_scale:  { values: [1.0, 1.5] }  # { value: 0.5 }
  head_wd_scale:  { value: 1.5 }
  head_keys:  { values: ["classification_head","classifier","mlp_head","fc","cls"] }

  # Optional warm freeze to let the head specialize
  freeze_backbone_warmup: { values: [false, true] }
  freeze_backbone_epochs: { value: 2 }

  # LR schedules (choose among these; knobs apply per strategy)
  lr_scheduler:    { values: [cosine, warmcos, plateau] }

  # cosine
  T_max:          { value: 40 }
  eta_min:        { value: 0.0 }

  # warmcos
  warmup_epochs:       { values: [0, 2, 3] }
  warmup_start_factor: { values: [0.1, 0.2] }

  # plateau
  plateau_metric:    { value: "val/auc" }
  plateau_mode:      { value: max }
  patience:          { value: 10 }
  factor:            { values: [0.5, 0.3] }
  plateau_threshold: { values: [0.0001, 0.0005] }

# parameters:
#   # Fixed / run control
#   architecture:          { value: vit }
#   task:                  { value: classification }
#   run_cap:               { value: 20 }
#   seed:                  { value: 42 }

#   # Execution/runtime
#   epochs:                { value: 40 }
#   num_workers:           { value: 8 }
#   batch_size:            { values: [32, 64] }
#   debug:                 { value: false }
#   console_iter_log:      { value: false }
#   console_epoch_log:     { value: true }

#   # Data / labels
#   in_channels:           { value: 1 }
#   input_shape:           { value: [256, 256] }
#   num_classes:           { value: 2 }
#   class_balance:         { value: inverse }

#   # ViT backbone
#   patch_size:            { value: 16 }
#   hidden_size:           { values: [384, 768] }
#   mlp_dim:               { values: [1536, 2048, 3072] }
#   num_layers:            { values: [8, 10, 12] }
#   num_heads:             { values: [6, 8, 12] }
#   dropout_rate:
#     distribution: uniform
#     min: 0.18
#     max: 0.24

#   # Classification head & probability mapping
#   head_logits:           { value: 1 }         # 1 → BCEWithLogits (single-logit binary head)
#   cls_loss:              { value: bce }
#   posprob_mode:          { value: auto }      # evaluator infers sigmoid/softmax from logits
#   positive_index:        { value: 1 }
#   init_head_bias_from_prior: { value: true }
#   init_threshold_from_prior:  { value: false }
#   cls_decision:          { value: threshold }
#   cls_threshold:         { values: [0.40, 0.50, 0.60] }  # seed; acceptance/guards decide final

#   # Validation stack / threshold search
#   two_pass_val:          { value: true }
#   calibration_method:    { values: [bal_acc, f1] }   # matches attach_val_threshold_search
#   cal_max_delta:         { values: [0.05, 0.10, 0.20] }
#   cal_auc_floor:         { values: [0.50, 0.55] }
#   cal_ema_beta:          { values: [0.10, 0.20, 0.30] }  # mapped to ema_beta internally
#   rate_tol_override:     { value: 0.10 }                # mapped to rate_tolerance

#   # Guardrails for threshold acceptance (authoritative)
#   thr_warmup_epochs:     { value: 5 }
#   thr_min:               { value: 0.05 }
#   thr_max:               { value: 0.95 }
#   thr_posrate_min:       { value: 0.05 }
#   thr_posrate_max:       { value: 0.95 }
#   thr_min_tp:            { values: [0, 5, 10] }
#   thr_min_tn:            { values: [0, 5] }
#   thr_hysteresis:        { values: [0.01, 0.02, 0.03] }

#   # Optimizer / param groups
#   optimizer:             { value: adamw }
#   lr:
#     distribution: log_uniform_values
#     min: 0.00003
#     max: 0.0008
#   weight_decay:
#     distribution: log_uniform_values
#     min: 0.00001
#     max: 0.00005

  # Split strategy (get_optimizer handles split/auto)
  # param_groups:          { values: [single, split, auto] }
  # head_lr_scale:         { value: 0.5 }
  # head_wd_scale:         { value: 1.5 }

#   # LR schedule
#   lr_strategy:           { values: [none, cosine, warmcos, plateau] }
#   # cosine
#   T_max:                 { value: 40 }
#   eta_min:               { value: 0.0 }
#   # warmcos
#   warmup_epochs:         { values: [0, 2, 3] }
#   warmup_start_factor:   { values: [0.1, 0.2] }
#   # plateau
#   plateau_metric:        { value: "val/auc" }
#   plateau_mode:          { value: max }
#   patience:              { value: 10 }
#   factor:                { values: [0.5, 0.3] }
#   plateau_threshold:     { values: [0.0001, 0.0005] }
