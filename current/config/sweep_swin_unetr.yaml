# sweep_swin_unetr.yaml
program: main.py
method: bayes

metric:
  name: val/dice
  goal: maximize

parameters:
  # Fixed experiment shape
  architecture: { value: swin_unetr }
  task:         { value: segmentation }
  run_cap:      { value: 20 }

  # Execution / logging
  epochs:            { value: 40 }
  num_workers:       { value: 8 }
  seed:              { value: 42 }
  debug:             { value: true }
  debug_transforms:  { value: false }
  console_iter_log:  { value: false }
  console_epoch_log: { value: true }

  # Data / labels
  in_channels:  { value: 1 }
  img_size:     { value: [256, 256] }
  out_channels: { value: 2 }
  batch_size:   { values: [4, 8, 16] }

  # SwinUNETR topology
  feature_size:   { values: [24, 32, 48] }
  depths:
    values:
      - [2, 2, 6, 2]
      - [2, 3, 6, 2]
  num_heads:
    values:
      - [3, 6, 12, 24]
      - [2, 4, 8, 16]
  window_size:     { values: [7, 8] }
  mlp_ratio:       { values: [3.0, 4.0] }
  norm_name:       { values: [instance, batch] }
  use_checkpoint:  { values: [false, true] }
  drop_rate:       { values: [0.0, 0.1] }
  drop_path_rate:  { values: [0.0, 0.1, 0.2] }

  # Loss weighting (e.g., Dice+CE)
  alpha: { values: [0.5, 1.0, 2.0] }
  beta:  { values: [0.25, 0.5, 1.0] }

  # Optimizer / regularization
  optimizer: { value: adamw }
  weight_decay:
    distribution: log_uniform_values
    min: 0.00001
    max: 0.001

  # Learning rate
  param_groups: { value: single }  # can switch to "split" if leveraging param_groups()
  lr:
    distribution: log_uniform_values
    min: 0.00003
    max: 0.0008

  # LR strategy
  lr_scheduler: { values: [none, cosine, warmcos, plateau] }

  # Cosine
  T_max:   { value: 40 }
  eta_min: { value: 0.0 }

  # Warmcos
  warmup_epochs:       { values: [0, 2, 3] }
  warmup_start_factor: { values: [0.1, 0.2] }

  # Plateau (monitor the sweep metric)
  plateau_metric:    { value: val/dice }
  plateau_mode:      { value: max }
  patience:          { values: [3, 6] }
  factor:            { values: [0.5, 0.3] }
  plateau_threshold: { values: [0.0001, 0.0005] }

  # Segmentation post-process
  seg_threshold: { value: 0.5 }


# # sweep_swin_unetr.yaml
# program: main.py
# method: bayes

# metric:
#   name: val/dice
#   goal: maximize

# parameters:
#   # Fixed experiment shape
#   architecture: { value: swin_unetr }
#   task:         { value: segmentation }
#   run_cap:      { value: 20 }

#   # Execution / logging
#   epochs:            { value: 40 }
#   num_workers:       { value: 12 }
#   seed:              { value: 42 }
#   debug:             { value: true }
#   debug_transforms:  { value: false }
#   console_iter_log:  { value: false }
#   console_epoch_log: { value: true }

#   # Data / labels
#   in_channels:  { value: 1 }
#   img_size:     { value: [256, 256] }
#   out_channels: { value: 2 }
#   batch_size:   { values: [4, 8, 16] }

#   # SwinUNETR topology
#   feature_size:   { values: [24, 32, 48] }
#   depths:
#     values:
#       - [2, 2, 6, 2]
#       - [2, 3, 6, 2]
#   num_heads:
#     values:
#       - [3, 6, 12, 24]
#       - [2, 4, 8, 16]
#   window_size:     { values: [7, 8] }
#   mlp_ratio:       { values: [3.0, 4.0] }
#   norm_name:       { values: [instance, batch] }
#   use_checkpoint:  { values: [false, true] }
#   drop_rate:       { values: [0.0, 0.1] }
#   drop_path_rate:  { values: [0.0, 0.1, 0.2] }

#   # Loss weighting (e.g., Dice+CE)
#   alpha: { values: [0.5, 1.0, 2.0] }
#   beta:  { values: [0.25, 0.5, 1.0] }

#   # Optimizer / regularization
#   optimizer: { value: adamw }
#   weight_decay:
#     distribution: log_uniform_values
#     min: 0.00001
#     max: 0.001

#   # Learning rate (single param group for seg is typical)
#   param_groups: { value: single }
#   lr:
#     distribution: log_uniform_values
#     min: 0.00003
#     max: 0.0008

#   # LR strategy (engine expects `lr_strategy`)
#   lr_strategy: { values: [none, cosine, warmcos, plateau] }

#   # Cosine params
#   T_max:   { value: 40 }
#   eta_min: { value: 0.0 }

#   # Warmcos params
#   warmup_epochs:       { values: [0, 2, 3] }
#   warmup_start_factor: { values: [0.1, 0.2] }

#   # Plateau params (monitor the sweep metric)
#   plateau_metric:    { value: "val/dice" }
#   plateau_mode:      { value: max }
#   patience:          { values: [3, 6] }
#   factor:            { values: [0.5, 0.3] }
#   plateau_threshold: { values: [0.0001, 0.0005] }

#   # Segmentation post-process
#   seg_threshold: { value: 0.5 }
